##################更改LISTENER监听端口###################### && set current_listener LISTENER && status && srvctl modify listener -l LISTENER -p "TCP:11521" && 重启当前listener && set current_listner LISTENER && status && Oracle数据库重设LOCAL_LISTENER && alter system set local_listener = '(ADDRESS=(PROTOCOL=TCP)(HOST=10.0.0.44)(PORT=11521))' sid='orcl1';
######################更改scan名称######################### && su - grid && srvctl modify | grep scan && srvctl config scan && srvctl stop listener && srvctl stop scan_listener && srvctl stop scan && crsctl stat res -t && su - root && srvctl modify scan -n new_scan_name && srvctl config scan && su - grid && srvctl start scan && srvctl start scan_listener && crs_stat -t | grep lsnr && srvctl start listener && crs_stat -t | grep lsnr
##################更改scan listener端口#################### && srvctl modify scan_listener -p 11521 && ps -ef | grep tns && set current_listener [scan_listener name] && restart
#############Oracle不知道密码情况下，更改用户密码############## && select NAME,PASSWORD from sys.user$;&& create user NAME identified by values 'E4CAB754187D323C' default tablespace USER temporary tablespace TEMP;
#####################杀 kill job 进程###################### && col program for a30 && select s.program,s.sid,s.serial#,s.status,s.username,d.job_name,p.spid,p.pid && from v$session s, v$process p, dba_datapump_sessions d where p.addr=s.paddr and s.saddr=d.saddr order by 5;
##################mysql8.0 锁信息查询####################### && select &&child.ENGINE,&& -- child.ENGINE_LOCK_ID,&& -- child.ENGINE_TRANSACTION_ID,&& child.THREAD_ID,&& -- child.EVENT_ID,&& concat(child.OBJECT_SCHEMA,'.',child.OBJECT_NAME) as OBJECT_NAME,&& child.INDEX_NAME,&& -- child.OBJECT_INSTANCE_BEGIN, The address in memory of the lock.&& child.LOCK_TYPE,&& child.LOCK_MODE,&& child.LOCK_STATUS,&& child.LOCK_DATA,&& parent.EVENT_NAME,&& parent.thread_id,&& parent.AUTOCOMMIT, -- 当前事务是否autocommit&& parent.ISOLATION_LEVEL,&& threads.PROCESSLIST_INFO,&& threads.THREAD_OS_ID&& FROM performance_schema.events_transactions_current AS parent&&   INNER JOIN performance_schema.data_locks AS child&&   INNER JOIN performance_schema.threads threads&& WHERE&&   parent.THREAD_ID = child.THREAD_ID&&   AND parent.EVENT_ID < child.EVENT_ID&&   AND (&&     child.EVENT_ID <= parent.END_EVENT_ID&&     OR parent.END_EVENT_ID IS NULL&&   )&&   AND threads.thread_id = child.thread_id;
###################Oracle全表扫描查询######################## &&--get the sql_id, child_number&&select&&        distinct inst_id, sql_id /* hash_value */ , child_number&&from&&        gv$sql_plan&&where   (operation = 'TABLE ACCESS' and options = 'FULL')&&or      (operation = 'INDEX' and options = 'FAST FULL SCAN')&&;&&-- get the sql_id, order  by total LIO&&set pages 1000&&col sqlt_sql_text for a30&&col LAST_LOAD_TIME for a19&&col FIRST_LOAD_TIME for a19&&select * from (&&select&&        INST_ID,&&        sql_id,&&        child_number,&&        plan_hash_value plan_hash,&&        first_load_time,&&        last_load_time,&&        executions,&&        trunc(elapsed_time/1000000) "elapsed_time(total(s))",&&        trunc(buffer_gets) "LIO(total)",&&        trunc(elapsed_time/decode(executions,0,1,executions)/1000000) "elapsed_time(s)/exec",&&        trunc(buffer_gets/decode(executions,0,1,executions)) "LIO/exec",&&       substr(sql_text,0,30) as sqlt_sql_text&&from&&        gv$sql&&where&&    (INST_ID, sql_id, child_number) in (&&      select&&          distinct inst_id, sql_id /* hash_value */ , child_number&&      from&&          gv$sql_plan&&      where   (operation = 'TABLE ACCESS' and options = 'FULL')&&      or      (operation = 'INDEX' and options = 'FAST FULL SCAN')&&    )&&        order by 1,8 desc,5&&) where rownum < 20&&/&&&&-- get the execution plan for the FTS sql&&select&&        plan_table_output  -- (the column of the pipelined function)&&from    (&&                select&&                        distinct sql_id, child_number&&                from&&                        v$sql_plan&&                where   (operation = 'TABLE ACCESS' and options = 'FULL')&&                or      (operation = 'INDEX' and options = 'FAST FULL SCAN')&&        ) v,&&        table(dbms_xplan.display_cursor(v.sql_id, v.child_number))&&;
###################Linux使用swap空间进程##################### && for i in `cd /proc;ls |grep "^[0-9]"|awk ' $0 >100'` ;do awk '/Swap:/{a=a+$2}END{print '"$i"',a/1024"M"}' /proc/$i/smaps ;done |sort -k2nr
#####################开启和关闭监听trace##################### && lsnrctl set trc_level 16 && 关闭监听trace && lsnrctl set trc_level 0
####################rac查看ocr备份恢复信息################### && 查看ocr信息 && ocrcheck && ocrconfig -showbackup && 改变物理备份路径 &&  ocrconfig -backuploc <new_dirname> && 使用物理备份恢复ocr &&  ocrconfig -restore <backup_file_name> && OCR的手动备份也即是逻辑备份，使用-export方式来实现 &&  ocrconfig -export <backup_file_name>
###############mysqlbinlog分析mysqldump#################### && mysqlbinlog -v --base64-output=decode-rows /usr/mysql_data-/bin.000002
###############OCR故障 更换OCR磁盘组 重建OCR################## && su - root && crsctl stop crs -f && ###启动到exclusive模式 && crsctl start crs -excl -nocrs && crsctl stat res -t -init && su - grid && sqlplus / as sysasm && alter diskgroup DATA mount; && su - root && ### 如果想更换OCR磁盘组需要更改ocr.loc 将原来的OCR盘改成DATA磁盘组 所有节点都改 && vi /etc/oracle/ocr.loc && ocrconfig_loc=+DATA && local_only=FALSE && ### restore OCR && ocrconfig -showbackup && ocrconfig -restore /u01/11.2.0/grid/cdata/peacebi-cluster/backup00.ocr && crsctl replace votedisk +DATA && Successful addition of voting disk 451ae1a82d504f11bfcf2b04e9095a14. && Successfully replaced voting disk group with +DATA. && CRS-4266: Voting file(s) successfully replaced && crsctl query css votedisk && crsctl stop crs -f && crsctl start crs && How to Restore ASM Based OCR After Complete Loss of the CRS Diskgroup on Linux/Unix Systems (Doc ID 1062983.1) && Linux/Unix 平台，在CRS 磁盘组完全丢失后，如何恢复基于 ASM 的 OCR (Doc ID 2331776.1)